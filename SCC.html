<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="keywords" content="SCC"/>
    <meta name="description" content="Strongly Connected Components"/>
    <meta name="author" content="Albert Hambardzumyan"/>

    <link rel="stylesheet" href="content/css/SCC.css">
    <link rel="stylesheet" href="content/css/app.css">
    <link rel="icon" href="content/icons/favicon.ico" type="image/x-icon"/>

    <script type="text/javascript" src="content/script/jquery_library.js"></script>
    <script type="text/javascript" src="content/script/figures.j"></script>
    <script type="text/javascript" src="content/script/menu.js"></script>

    <title>SCC</title>
</head>
<body id="body">

<div id="main_container">
    <span id="back">&#9668 Go Back</span>

    <div id="header">
        <a class="headerLogo" href="http://ac.aua.am/albert_hambardzumyan/Web/Algorithm%20Project/SCC.html">
            <p>Strongly Connected Components</p>
        </a>
    </div>


    <div id="menuBG">
        <div id="menu">
            <div id='menuTab'>
                <ul>
                    <li class="menu_tab">
                        <a id="overview">
                            <span>Overview</span>
                        </a>
                    </li>
                    <li class="menuTab_separator menu_tab"></li>
                    <li class="menu_tab">
                        <a id="complexity">
                            <span>Complexity</span>
                        </a>
                    </li>
                    <li class="menuTab_separator menu_tab"></li>
                    <li class="menu_tab">
                        <a id="applications">
                            <span>Applications</span>
                        </a>
                    </li>
                    <li class="menuTab_separator menu_tab"></li>
                    <li class="menu_tab">
                        <a id="try_it_out">
                            <span>Try It Out</span>
                        </a>
                    </li>

                    <li class="menuTab_separator menu_tab"></li>
                    <li class="menu_tab">
                        <a id="resources">
                            <span>Bibliography</span>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>


    <div class="container">

        <div id="overview1" class="page">
            <p>Agenda</p>
            <ul>
                <li><a id="intro" href="#introduction"><span>Introduction</span></a></li>
                <li><a id="def" href="#definitions"><span>Definitions</span></a></li>
                <li><a id="det" href="#detail"><span>Connectivity of Graphs</span></a></li>
                <li><a id="algo" href="#algorithms"><span>Algorithms</span></a></li>
                <ul>
                    <li><a id="kos" href="#kosaraju"><span>Kosaraju's algorithm</span></a></li>
                    <li><a id="tar" href="#tarjan"><span>Tarjan's algorithm</span></a></li>
                    <li><a id="pa" href="#path"><span>Gabow's path-based algorithm</span></a></li>
                </ul>
            </ul>

            <div class="line"></div>
            <div class="white_block"></div>

            <div id="introduction">
                <p>Introduction</p>
                <div class="introduction_sub_container">
                    <p>A Graph is considered strongly connected if every vertex in the graph can be reached from every
                        other vertex. An arbitrary <a class="links" href="#directed_graph"><em>directed graph</em></a>
                        may have strongly connected components, which are defined as partitions of subgraphs that are
                        themselves strongly connected.</p>
                    <p>In other words, a directed graph is strongly connected if there is a path between all pairs of
                        vertices and strongly connected component (SCC) of a directed graph is a maximal strongly
                        connected subgraph.</p>
                    <p>It is possible to check the strong connectivity of a graph and to compute the strongly connected
                        components of a directed graph in linear time. We present three fundamental algorithms in graph
                        theory that are connected to this topic: Kosaraju's algorithm (also known as the Kosaraju-Sharir
                        algorithm),<a id="r1" class="ref" href="#body">[1]</a> Tarjan’s algorithm,<a id="r2" class="ref"
                                                                                                     href="#body">[2]</a>
                        and Gabow's path-based algorithm.<a id="r3" class="ref" href="#body">[3]</a></p>
                </div>
            </div>

            <div class="line"></div>
            <div class="white_block"></div>

            <div id="definitions">
                <p>Definitions</p>
                <div class="definitions_sub_container">
                    <p id="directed_graph"><b>Directed graph</b> - A directed graph (V, E) consists of a nonempty set of
                        vertices V and a set of <em>directed edges E</em>. Each directed edge is associated with an
                        ordered pair of vertices. The directed edge associated with the ordered pair (<em>u, v</em>) is
                        said to <em>start</em> at <em>u</em> and <em>end</em> at <em>v</em><a id="r4" class="ref"
                                                                                              href="#body">.[4]</a> In
                        other words, a set of vertices together with a set of directed edges each of which is associated
                        with an ordered pair of vertices<a id="r5" class="ref" href="#body">.[5]</a></p>
                    <p id="undirected_graph"><b>Undirected graph</b> - An undirected graph is one in which edges have no
                        orientation. The edge (a, b) is identical to the edge (b, a), i.e., they are not ordered pairs,
                        but sets {u, v} of vertices. The maximum number of edges in an undirected graph without a
                        self-loop is n*(n - 1)/2<a id="r6" class="ref" href="#body">.[6]</a> In other words, a set of
                        vertices and a set of undirected edges each of which is associated with a set of one or two of
                        these vertices<a id="r7" class="ref" href="#body">.[7]</a></p>
                    <p id="reflexive"><b>Reflexive relation</b> - A relation R on a set A is called <em>reflexive</em>
                        if (a, a) ϵ R for every element a ϵ A. In other words, a relation on A is reflexive if every
                        element of A is related to itself<a id="r8" class="ref" href="#body">.[8]</a></p>
                    <p id="symmetric"><b>Symmetric relation</b> - A relation R on a set A is called <em>symmetric</em>
                        if (b, a) ϵ R whenever (a, b) ϵ R, for all a, b ϵ A. That is, a relation is symmetric if and
                        only if <em>a</em> is related to <em>b</em> implies that <em>b</em> is related to <em>a</em><a
                                id="r9" class="ref" href="#body">.[9]</a></p>
                    <p id="transitive"><b>Transitive relation</b> - A relation R on a set A is called
                        <em>transitive</em> if whenever (a, b) ϵ R and (b, c) ϵ R, than (a, c) ϵ R, for all a, b, c ϵ
                        A<a id="r10" class="ref" href="#body">.[10]</a></p>
                    <p id="equivalence"><b>Equivalence relation</b> - A relation on a set A is called an <em>equivalence
                        relation</em> if it is reflexive, symmetric, and transitive. Two elements <em>a</em> and
                        <em>b</em> that are related by an equivalence relation are called <em>equivalent</em><a id="r11"
                                                                                                                class="ref"
                                                                                                                href="#body">.[11]</a>
                    </p>
                    <p id="dag"><b>Directed acyclic graph </b> (abbreviated as DAG) - A directed graph G is acyclic if
                        and only if a depth-first-search of G yields no back edges<a id="r12" class="ref" href="#body">.[12]</a>
                    </p></p>
                    <p id="source"><b>Source vertex</b> - A vertex with in-degree 0 is a source. In other words, a
                        vertex does not have incoming edges<a id="r13" class="ref" href="#body">.[13]</a></p>
                    <p id="sink"><b>Sink vertex</b> - A vertex with out-degree 0 is a sink. In other words, a vertex
                        does not have outgoing edges<a id="r14" class="ref" href="#body">.[14]</a></p>
                    <p id="sink_strongly_connected_component"><b>Sink strongly connected component</b> - A strongly
                        connected component that has no edges leaving it in the dag of strongly connected components</p>
                    <p id="adjacency_list"><b>Adjacency list</b> - An adjacency list structure consists of an n-element
                        array V, where V[i] represents node i<a id="r31" class="ref" href="#body">.[15]</a></p>
                    <p id="adjacency_matrix"><b>Adjacency matrix</b> - An adjacency matrix is simply a two-dimensional
                        array A, with n rows and n columns, where n = |V|<a id="r32" class="ref" href="#body">.[16]</a>
                    </p>

                </div>
            </div>

            <div class="line"></div>
            <div class="white_block"></div>

            <div id="detail">
                <p>Connectivity of Graphs</p>
                <div class="detail_sub_container">

                    <p>The connectivity of <a class="links" href="#undirected_graph"><em>undirected graphs</em></a> is
                        easy to understand: as we know a graph is considered connected when there is a path between
                        every pair of distinct vertices of the graph<a id="o50" class="ref" href="#body">.[17]</a> And
                        because the direction of the edges does not matter in an undirected graph, it is obvious that if
                        there is an edge between two vertices, then path between them exists.</p>
                    <p> An <em>undirected graph</em> that is not connected can be decomposed into several <em>connected
                        components</em> that can be viewed as connected subgraphs of G of maximum size <a class="links"
                                                                                                          href="#figure1"><em>(Figure
                        1)</em></a>. Connected components can be easily computed with Depth-First search<a id="o51"
                                                                                                           class="ref"
                                                                                                           href="#body">.[18]</a>
                        At each restart of the algorithm, it marks a new connected component.</p>
                    <p id="figure1"></p>
                    <div>
                        <svg width="430" height="200" id="figure_1_svg">
                            <circle id="circle0" cx="80" cy="20" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="76" y="24">0</text>
                            <circle id="circle1" cx="140" cy="50" r="12" fill="#FF7F0E" stroke="#B25809"
                                    stroke-width="2"/>
                            <text x="136" y="54">1</text>
                            <circle id="circle2" cx="90" cy="90" r="12" fill="#2CA02C" stroke="#217C21"
                                    stroke-width="2"/>
                            <text x="86" y="94">2</text>
                            <circle id="circle3" cx="200" cy="120" r="12" fill="#D62728" stroke="#951B1C"
                                    stroke-width="2"/>
                            <text x="196" y="124">3</text>
                            <circle id="circle4" cx="40" cy="150" r="12" fill="#9467BD" stroke="#674884"
                                    stroke-width="2"/>
                            <text x="36" y="154">4</text>
                            <circle id="circle5" cx="140" cy="160" r="12" fill="#8C564B" stroke="#623C34"
                                    stroke-width="2"/>
                            <text x="136" y="164">5</text>
                            <circle id="circle6" cx="250" cy="40" r="12" fill="#E377C2" stroke="#AF5B95"
                                    stroke-width="2"/>
                            <text x="246" y="44">6</text>
                            <circle id="circle7" cx="300" cy="80" r="12" fill="#7F7F7F" stroke="#585858"
                                    stroke-width="2"/>
                            <text x="296" y="84">7</text>
                            <circle id="circle8" cx="370" cy="20" r="12" fill="#BCBD22" stroke="#8D8E18"
                                    stroke-width="2"/>
                            <text x="366" y="24">8</text>
                            <circle id="circle9" cx="350" cy="150" r="12" fill="#17BECF" stroke="#108590"
                                    stroke-width="2"/>
                            <text x="346" y="154">9</text>

                            <line x1="91" y1="24" x2="129" y2="46" stroke="black" stroke-width="2"/>
                            <line x1="80" y1="33" x2="82" y2="80" stroke="black" stroke-width="2"/>
                            <line x1="149" y1="59" x2="192" y2="112" stroke="black" stroke-width="2"/>
                            <line x1="133" y1="60" x2="101" y2="84" stroke="black" stroke-width="2"/>
                            <line x1="102" y1="95" x2="187" y2="120" stroke="black" stroke-width="2"/>
                            <line x1="53" y1="150" x2="127" y2="160" stroke="black" stroke-width="2"/>
                            <line x1="259" y1="49" x2="289" y2="73" stroke="black" stroke-width="2"/>
                            <line x1="263" y1="39" x2="357" y2="20" stroke="black" stroke-width="2"/>
                            <line x1="367" y1="32" x2="354" y2="138" stroke="black" stroke-width="2"/>

                        </svg>
                        <br/>Figure 1: An undirected graph
                    </div>

                    <p>In a <em>directed graph</em>, however, connectivity is more complicated. In an intuitive sense,
                        the directed graph in <a class="links" href="#figure2"><em>Figure 2</em></a> can be considered
                        as "connected" (because no part of it is apart from the entire graph), but in reality it is not
                        connected because due to the edge directions there are some nodes that do not have path to each
                        other . For example, there is no path from node 10 to 5, or from 6 to 2.</p>
                    <p>So we define connectivity in directed graph as follows: call two nodes <em>u</em> and <em>v</em>
                        of a directed graph G = (V, E) <em>connected</em> if there is a path from <em>u</em> to
                        <em>v</em>, and from <em>v</em> to <em>u</em> whenever <em>a</em> and <em>b</em> are vertices in
                        the graph<a id="o52" class="ref" href="#body">.[19]</a> This relation between nodes is <a
                                class="links" href="#reflexive"><em>reflexive</em></a>, <a class="links"
                                                                                           href="#symmetric"><em>symmetric</em></a>
                        and <a class="links" href="#transitive"><em>transitive</em></a>, so it is an <a class="links"
                                                                                                        href="#equivalence"><em>equivalence
                            relation</em></a> on the nodes. It means that V can be partitioned into disjoint sets,
                        called <em>strongly connected components</em> of the graph. A strongly connected component of a
                        directed graph G is a subgraph that is strongly connected, and is maximal with this property: no
                        additional edges or vertices from G can be included in the subgraph without breaking its
                        property of being strongly connected. In the directed graph of <a class="links" href="#figure2"><em><br>Figure
                            2</em></a> there are four strongly connected components.</p>

                    <p id="figure2"></p>
                    <div>
                        <svg width="430" height="430" id="figure_2_svg">

                            <defs>
                                <marker id="Triangle" viewBox="0 0 20 20" refX="0" refY="10" markerUnits="strokeWidth"
                                        markerWidth="8" markerHeight="5" orient="auto">
                                    <path d="M 0 0 L 20 10 L 0 20 z"/>
                                </marker>
                            </defs>

                            <circle cx="40" cy="30" r="12" fill="#1F77B4" stroke="#15537D" stroke-width="2"/>
                            <text x="36" y="34">1</text>
                            <circle cx="140" cy="30" r="12" fill="#FF7F0E" stroke="#B25809" stroke-width="2"/>
                            <text x="136" y="34">2</text>
                            <circle cx="280" cy="30" r="12" fill="#2CA02C" stroke="#217C21" stroke-width="2"/>
                            <text x="276" y="34">3</text>
                            <circle cx="90" cy="120" r="12" fill="#D62728" stroke="#951B1C" stroke-width="2"/>
                            <text x="86" y="124">4</text>
                            <circle cx="180" cy="120" r="12" fill="#9467BD" stroke="#674884" stroke-width="2"/>
                            <text x="176" y="124">5</text>
                            <circle cx="280" cy="120" r="12" fill="#8C564B" stroke="#623C34" stroke-width="2"/>
                            <text x="276" y="124">6</text>
                            <circle cx="180" cy="210" r="12" fill="#E377C2" stroke="#AF5B95" stroke-width="2"/>
                            <text x="176" y="214">7</text>
                            <circle cx="280" cy="210" r="12" fill="#7F7F7F" stroke="#585858" stroke-width="2"/>
                            <text x="276" y="214">8</text>
                            <circle cx="140" cy="300" r="12" fill="#BCBD22" stroke="#8D8E18" stroke-width="2"/>
                            <text x="136" y="304">9</text>
                            <circle cx="230" cy="300" r="12" fill="#1F77B4" stroke="#15537D" stroke-width="2"/>
                            <text x="222" y="304">10</text>
                            <circle cx="320" cy="300" r="12" fill="#FF7F0E" stroke="#B25809" stroke-width="2"/>
                            <text x="312" y="304">11</text>
                            <circle cx="280" cy="390" r="12" fill="#2CA02C" stroke="#217C21" stroke-width="2"/>
                            <text x="272" y="394">12</text>

                            <line x1="53" y1="30" x2="117" y2="30" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/><!--x1 +13, x2 -23 -->
                            <line x1="153" y1="30" x2="257" y2="30" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="131" y1="39" x2="98" y2="99" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/><!--x1.y2 +-9, x2.y2 +-9 ?-->
                            <line x1="103" y1="120" x2="157" y2="120" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="193" y1="120" x2="257" y2="120" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="99" y1="129" x2="161" y2="201" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="180" y1="133" x2="180" y2="187" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/><!--y1 +13, y2 -23 -->
                            <line x1="280" y1="133" x2="280" y2="187" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="187" y1="221" x2="220" y2="279" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="145" y1="288" x2="170" y2="231" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="217" y1="300" x2="163" y2="300" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="243" y1="300" x2="297" y2="300" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="272" y1="379" x2="240" y2="321" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="314" y1="312" x2="291" y2="369" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                            <path d="M140 43 Q 140 80 164 104" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M180 107 Q 180 70 156 46" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M285 42 Q 300 65 290 100" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M275 108 Q 260 80 270 50" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M192 205 Q 225 190 260 200" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M268 215 Q 235 230 200 220" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>

                            <path d="M15,30a25,25 0 1,0 50,0a25,25 0 1,0 -50,0" fill="none" stroke="red"
                                  stroke-width="1" stroke-dasharray="3,3"/>
                            <path d="M62,85a75,75 0 1,0 150,0a75,75 0 1,0 -150,0" fill="none" stroke="red"
                                  stroke-width="1" stroke-dasharray="3,3"/>
                            <path d="M250,75a30,70 0 1,0 60,0a30,70 0 1,0 -60,0" fill="none" stroke="red"
                                  stroke-width="1" stroke-dasharray="3,3"/>
                            <path d="M120,300a110,130 0 1,0 220,0a110,130 0 1,0 -220,0" fill="none" stroke="red"
                                  stroke-width="1" stroke-dasharray="3,3"/>

                        </svg>
                        <br/>Figure 2: A directed graph and its strongly connected components
                    </div>

                    <p>We can combine each of these strongly connected components into a single node and draw an edge
                        between two of them if there is an edge from some node in the first strongly connected component
                        to some node in the second strongly connected component. The resulting directed graph has to be
                        a <a class="links" href="#dag"><em>directed acyclic graph (DAG)</em></a> <a class="links"
                                                                                                    href="#figure3"><em>(Figure
                            3)</em></a>. The explanation for this is simple: a cycle containing several strongly
                        connected components would merge them all to a single strongly connected components.<br/>
                        We can restate this observation as follows: every directed graph is a DAG of its strongly
                        connected components.</p>

                    <p id="figure3"></p>
                    <div>
                        <svg width="430" height="230" id="figure_3_svg">

                            <defs>
                                <marker id="Triangle" viewBox="0 0 20 20" refX="0" refY="10" markerUnits="strokeWidth"
                                        markerWidth="8" markerHeight="5" orient="auto">
                                    <path d="M 0 0 L 20 10 L 0 20 z"/>
                                </marker>
                            </defs>
                            <path d="M25,45a30,15 0 1,0 60,0a30,15 0 1,0 -60,0" fill="#1F77B4" stroke="#15537D"
                                  stroke-width="2"/>
                            <path d="M160,45a40,15 0 1,0 80,0a40,15 0 1,0 -80,0" fill="#FF7F0E" stroke="#B25809"
                                  stroke-width="2"/>
                            <path d="M315,45a35,15 0 1,0 70,0a35,15 0 1,0 -70,0" fill="#2CA02C" stroke="#217C21"
                                  stroke-width="2"/>
                            <path d="M200,165a80,15 0 1,0 160,0a80,15 0 1,0 -160,0" fill="#D62728" stroke="#951B1C"
                                  stroke-width="2"/>

                            <text x="50" y="50">1</text>
                            <text x="185" y="50">2-4-5</text>
                            <text x="340" y="50">3-6</text>
                            <text x="240" y="170">7-8-9-10-11-12</text>

                            <line x1="86" y1="45" x2="149" y2="45" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="241" y1="45" x2="304" y2="45" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="198" y1="61" x2="260" y2="142" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="351" y1="61" x2="300" y2="142" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                        </svg>
                        <br/>Figure 3: Dag of strongly connected components
                    </div>

                    <p id="theorem_of_dag"><br/>Theorem: the Component Graph <br/><br/>G<sup>SCC</sup> =
                        (V<sup>SCC</sup>, E<sup>SCC</sup>) is a DAG<br/>
                        - Each component is maximal in the sense that no other vertices can be added to it. <br/>
                        - If G<sup>SCC</sup> = (V<sup>SCC</sup>, E<sup>SCC</sup>) is not a DAG, then one can merge
                        components on along a circle of G<sup>SCC</sup><br/>
                        Therefore, G<sup>SCC</sup> has a topological ordering<a id="o53" class="ref"
                                                                                href="#body">.[20]</a>
                    </p>
                    <p id="dag_dag'">Also, note that if graph G is a DAG then G'(with the directions of all edges
                        reversed) is also a DAG. Moreover, G has precisely the same DAG as G'. In other words, G and G'
                        have the same strongly connected components<a id="o54" class="ref" href="#body">.[21]</a></p>
                </div>
            </div>

            <div class="line"></div>
            <div class="white_block"></div>

            <div id="algorithms">
                <p>Algorithms</p>
                <div class="algorithms_sub_container">
                    <p>There are several efficient algorithms for computing strongly connected components in directed
                        graphs. Particularly there are three well-known algorithms that can find strongly connected
                        components in linear time, and they all are based on depth-first search.</p>
                    <p>The first algorithm we are going to discuss is Kosaraju's algorithm represented in an unpublished
                        paper in 1978. Later this algorithm was published by Micha Sharir in 1981. It is based on two
                        depth-first searches, one performed on a graph and the second on its reverse graph. </p>
                    <p>The second algorithm for computing strongly connected components is Tarjan’s Algorithm,
                        represented by Robert Tarjan in 1972. It requires only one depth-first search, and it can be
                        considered as an improved version of Kosaraju's algorithm.</p>
                    <p>The third algorithm for computing strongly connected components is Gabow's path-based strong
                        component algorithm, represented by Harold N. Gabow in 2000, which uses a depth-first search
                        like Tarjan's algorithm, but with two stacks.</p>
                </div>
            </div>

            <div class="line"></div>
            <div class="white_block"></div>

            <div id="kosaraju">
                <p>• Kosaraju's algorithm</p>
                <div class="kosaraju_sub_container">

                    <p> Input: A directed graph G = (V, E)<br/>
                        Output: a partition of V into disjoint sets so that each set defines a strongly connected
                        component of G<br/>
                        How should we compute the partition?</p>
                    <p>The above mentioned <a class="links" href="#theorem_of_dag"><em>theorem</em></a> allows us to
                        understand the delicate connectivity information of a directed graph in these two-level
                        manner:<br/>
                        - At the top level we have a dag, a structure which is rather simple. For example, we know that
                        a dag has at least one <a class="links" href="#source"><em>source</em></a> and at least one <a
                                class="links" href="#sink"><em>sink</em></a>, and can be topologically sorted.<br/>
                        - If more details are needed, we look inside a node of the dag to see the existing fully-fledged
                        strongly connected component (a tightly connected graph).</p>

                    <p> The decomposition algorithms that we will discuss are based on depth-first search.<br/>
                        To completely understand why we use depth-first search in some existing algorithms for
                        decomposition, let us examine some properties of depth-first search.</p>

                    <p id="property_1"><b><em>Property 1:</em></b> Consider that depth-first search of a graph starts at
                        a node <em>u</em>. It will get stuck and restarted again when all nodes that are reachable from
                        <em>u</em> have been visited.
                        Thus, if depth-first search starts at a node of a <a class="links"
                                                                             href="#sink_strongly_connected_component"><em>sink
                            strongly connected component</em></a>, it will get stuck after it visits precisely all the
                        nodes of this strongly connected component.
                        For example, if a depth-first search starts at node 11 in <a class="links" href="#figure2"><em>Figure
                            2</em></a> (a node in the only sink strongly connected component in this graph), then it
                        will visit nodes 11, 12, 10, 9, 7, 8 and then get stuck.
                        Using <em>Property 1</em> we can start the decomposition algorithm, by finding our first
                        strongly connected component: <b><em>start from any node in a sink strongly connected
                            components</em></b>, and, if stuck, output the nodes that have been visited. The output will
                        be our strongly connected component.</p>

                    <p id="problems">This approach arises some problems:</p>
                    <p id="problem_1"> &emsp;1) finding a node in a sink strongly connected component.</p>
                    <p id="problem_2"> &emsp;2) continuing the algorithm after outputting the first strongly connected
                        component and finding next strongly connected components</p>
                    <p>The 1-st problem is hard to solve because there is no direct way to obtain a node in a sink
                        strongly connected component. But we can obtain a node in a <em>source</em> strongly connected
                        component.
                        In particular:</p>

                    <p id="property_2"><b><em>Property 2:</em></b> Let C and C' be two strongly connected components of
                        a graph, and suppose that there is an edge from a node of C to a node of C'.
                        The node of C that was visited by depth-first search firstly has higher <b><em>finishing
                            time</em></b> than any node of C'.</p>
                    <p><em>Proof of Property 2:</em></p>
                    <p>There are two cases: either C is visited before C' by depth-first search, or vise versa:<br/>
                        1) in the first case, depth-first search, started at C, visited all nodes of C and C' before
                        getting stuck, and thus the node of C visited first was the last among the nodes of C and C' to
                        finish.<br/>
                        2) if C' was visited before C by depth-first search, then depth-first search from it was stuck
                        before visiting any node of C (the nodes of C are not reachable from C'), and thus again the
                        property is true.</p>

                    <p>From <a class="links" href="#property_2"><em>property 2</em></a> we can derive more specific fact
                        about dept-first search.</p>
                    <p id="property_3"><b><em>Property 3:</em></b> The node with the highest <b><em>finishing time</em></b>
                        number in depth-first search (that is, the node where the depth-first search ends) belongs to a
                        source strongly connected component.</p>
                    <p>This property provides an indirect solution to <a class="links" href="#problem_1"><em>problem
                        (1)</em></a>: consider the <em>reverse</em> graph of G = (V, E), G' = (V, E') with the
                        directions of all edges reversed.
                        As we mentioned <a class="links" href="#dag_dag'"><em>above</em></a> G has precisely the same
                        strongly connected components as G'. So if we make a depth-first search in G, then the node
                        where we end (the one with the highest <b><em>finishing time</em></b> number) belongs to a
                        source strongly connected component of G, in other words, a sink strongly connected component of
                        G'. So the Problem(1) can be solved using this property.</p>

                    <p>Now let us discuss the <a class="links" href="#problem_2"><em>problem (2)</em></a>: how can we
                        continue after the first outputted sink component to the second strongly connected component,
                        the third strongly connected component, and so on.
                        The solution to this problem is also provided by <a class="links" href="#property_2"><em>property
                            2</em></a>: аfter we output the first strongly connected component and delete it from the
                        graph, the node with the highest <b><em>finishing time</em></b> from the depth-first search of
                        G' among the remaining nodes belongs to a sink strongly connected component of the remaining
                        graph. Thus, we can use the same depth-first search information from G' to output the second
                        one, the third one, and so on.</p>

                    <p>Strongly-Connected-Components(G)</p>

                    <p>[1] Perform a depth-first search on the graph G to compute finishing times f [u] for each vertex
                        u. Renumber vertices by finishing time.</p>
                    <p>[2] Let G' be the reverse directed graph of G derived by reversing direction of each edge.</p>
                    <p>[3] Perform a depth-first search on the graph G', with the following condition: in the main loop
                        of depth-first search consider the vertices in order of decreasing finishing times (starting at
                        highest numbered vertex).</p>
                    <p>[4] Output the vertices of each tree formed in second depth-first search as a separate strongly
                        connected component.[~]</p>
                    <p>Repeat step [3]-[4] starting at highest numbered vertex not so for visited. Stop when all
                        vertices visited.</p>


                    <p><br/>The outcome of this algorithm after running it on the directed graph illustrated in the <a
                            class="links" href="#figure2"><em>Figure 2</em></a> will be the following:<br/><br/>

                        Step [1] will produce the following order on the nodes {7, 9, 10, 12, 11, 8, 3, 6, 2, 5, 4,
                        1}<br/>

                        Step [3] discovers the following strongly connected components:<br/>
                        component 1: {7, 8, 10, 9, 11, 12}<br/>
                        component 2: {3, 6}<br/>
                        component 3: {2, 4, 5}<br/>
                        component 4: {1}<br/>


                    <p><b>Let us discuss the logic behind this algorithm more specifically.</b></p>

                    <p>As we saw above this algorithm is based on depth-first search with two passes. Let us explain how
                        does this algorithm work on another graph.<br/>

                    <p id="figure4"></p>
                    <div>
                        <svg width="430" height="200" id="figure_4_svg">

                            <defs>
                                <marker id="Triangle" viewBox="0 0 20 20" refX="0" refY="10" markerUnits="strokeWidth"
                                        markerWidth="8" markerHeight="5" orient="auto">
                                    <path d="M 0 0 L 20 10 L 0 20 z"/>
                                </marker>
                            </defs>
                            <circle cx="70" cy="30" r="12" fill="#1F77B4" stroke="#15537D" stroke-width="2"/>
                            <text x="66" y="34">1</text>
                            <circle cx="190" cy="30" r="12" fill="#FF7F0E" stroke="#B25809" stroke-width="2"/>
                            <text x="186" y="34">2</text>
                            <circle cx="70" cy="140" r="12" fill="#2CA02C" stroke="#217C21" stroke-width="2"/>
                            <text x="66" y="144">3</text>
                            <circle cx="330" cy="30" r="12" fill="#D62728" stroke="#951B1C" stroke-width="2"/>
                            <text x="326" y="34">4</text>
                            <circle cx="330" cy="140" r="12" fill="#9467BD" stroke="#674884" stroke-width="2"/>
                            <text x="326" y="144">5</text>

                            <line x1="83" y1="30" x2="167" y2="30" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="203" y1="30" x2="307" y2="30" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="70" y1="127" x2="70" y2="53" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="181" y1="39" x2="86" y2="124" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="330" y1="43" x2="330" y2="117" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                        </svg>
                        <br/>Figure 4: A directed graph
                    </div>

                    <p>According to the <a class="links" href="#property_1"><em>Property 1</em></a>, to find and output
                        all strongly connected components we should start from any node in a sink strongly connected
                        component, which in our case has only one vertex, thus we should start depth-first search from
                        that sink vertex 5. Then we move to the vertex 4, which is a sink vertex in the remaining set,
                        and finally to the rest remaining vertices (1, 2, 3).</p>

                    <p>As we mentioned <a class="links" href="#problems"><em>above</em></a>, one hard problem still
                        remains: how to find the sequence of picking vertices as starting points of depth-first search.
                    </p>

                    <p>Using the <a class="links" href="#property_2"><em>Property 2</em></a>, we do a depth-first search
                        on a graph and store vertices according to their finishing times. By doing so, we make sure that
                        the finishing time of a vertex that connects to other strongly connected components will always
                        be greater than finishing time of vertices in the other strongly connected components. For
                        example, in a depth-first search of above example graph <a class="links" href="#figure4"><em>Figure
                            4</em></a>, finishing time of vertex 1 is always greater than finishing times of vertices 4
                        and 5. And finishing time of vertex 4 is always greater than finishing time of vertex 5.</p>

                    <p>According to the <a class="links" href="#property_3"><em>Property 3</em></a> the vertex that has
                        the highest finishing time in graph G belongs to a source strongly connected component and after
                        reversing the graph G the same vertex will belong to a sink SCC of G'. For example, consider the
                        graph G of strongly connected components of <a class="links" href="#figure5"><em>Figure
                            5</em></a>.</p>

                    <p id="figure5"></p>
                    <div>
                        <svg width="430" height="230" id="figure_5_svg">

                            <defs>
                                <marker id="Triangle" viewBox="0 0 20 20" refX="0" refY="10" markerUnits="strokeWidth"
                                        markerWidth="8" markerHeight="5" orient="auto">
                                    <path d="M 0 0 L 20 10 L 0 20 z"/>
                                </marker>
                            </defs>

                            <path d="M35,50a40,15 0 1,0 80,0a40,15 0 1,0 -80,0" fill="#1F77B4" stroke="#15537D"
                                  stroke-width="2"/>
                            <path d="M180,50a35,15 0 1,0 70,0a35,15 0 1,0 -70,0" fill="#FF7F0E" stroke="#B25809"
                                  stroke-width="2"/>
                            <path d="M315,50a35,15 0 1,0 70,0a35,15 0 1,0 -70,0" fill="#2CA02C" stroke="#217C21"
                                  stroke-width="2"/>

                            <text x="60" y="55">1-2-3</text>
                            <text x="210" y="55">4</text>
                            <text x="345" y="55">5</text>
                            <text x="170" y="25">Graph of SCCs</text>

                            <line x1="116" y1="50" x2="169" y2="50" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="251" y1="50" x2="304" y2="50" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                            <path d="M35,170a40,15 0 1,0 80,0a40,15 0 1,0 -80,0" fill="#1F77B4" stroke="#15537D"
                                  stroke-width="2"/>
                            <path d="M180,170a35,15 0 1,0 70,0a35,15 0 1,0 -70,0" fill="#FF7F0E" stroke="#B25809"
                                  stroke-width="2"/>
                            <path d="M315,170a35,15 0 1,0 70,0a35,15 0 1,0 -70,0" fill="#2CA02C" stroke="#217C21"
                                  stroke-width="2"/>

                            <text x="60" y="175">1-2-3</text>
                            <text x="210" y="175">4</text>
                            <text x="345" y="175">5</text>
                            <text x="150" y="145">SCCs in reverse graph</text>

                            <line x1="179" y1="170" x2="126" y2="170" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="314" y1="170" x2="261" y2="170" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                        </svg>
                        <br/>Figure 5: SCCs in original and reverse graphs
                    </div>

                    <p>In the reversed graph, the edges that connect two components are reversed. So the strongly
                        connected component {1, 2, 3} becomes sink and the strongly connected component {5} becomes
                        source.</p>
                    <p>Now using vertex with highest finishing time, we can do depth-first search to explore and output
                        all vertices in that sink strongly connected component of G', delete it, and move to the next
                        sink strongly connected component. </p>
                    <p> And as we mentioned <a class="links" href="#dag_dag'"><em>above</em></a> G' has the same
                        strongly connected components as G, thus finding strongly connected components in G' will solve
                        our problem.<br/> That is what we wanted to achieve, and that is all needed to print strongly
                        connected components one by one.</p>
                    <p><b>To summarize, let us define Kosaraju's algorithm as follows:</b></p>
                    <p>Kosaraju's algorithm is based on two passes of depth-first search.The first one runs on the
                        original graph and is used to choose the order in which the outer loop of the second depth-first
                        search tests vertices for having been visited already and recursively explores them if not. The
                        second depth-first search runs on the transpose graph of the original one, and each recursive
                        call finds a single new strongly connected component.</p>
                    <p> The following is a detailed Kosaraju’s algorithm:</p>
                    <p>• Create an empty stack "S" and do depth-first search traversal of a graph. In depth-first search
                        traversal, after calling recursive depth-first search for adjacent vertices of a vertex, push
                        the vertex to stack.</p>
                    <p>• Reverse directions of all arcs to get the transpose graph.</p>
                    <p>• Set all the vertices unvisited and one by one pop a vertex from S while S is not empty. Let the
                        popped vertex be "v". Take v as starting point and do a depth-first search if it is not visited
                        yet. The depth-first search starting from v prints strongly connected component of v.</p>

                    <p><b>Demonstration of Kosaraju's Algorithm</b></p>
                    <div id="kosaraju_demonstration_div">
                        <svg width="500" height="250" id="kosaraju_demonstration">
                            <circle id="circle1" cx="60" cy="60" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="56" y="64">1</text>
                            <circle id="circle2" cx="160" cy="60" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="156" y="64">2</text>
                            <circle id="circle3" cx="260" cy="60" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="256" y="64">3</text>
                            <circle id="circle4" cx="360" cy="60" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="356" y="64">4</text>
                            <circle id="circle5" cx="60" cy="160" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="56" y="164">5</text>
                            <circle id="circle6" cx="160" cy="160" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="156" y="164">6</text>
                            <circle id="circle7" cx="260" cy="160" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="256" y="164">7</text>
                            <circle id="circle8" cx="360" cy="160" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="356" y="164">8</text>

                            <line id="line1" x1="73" y1="60" x2="137" y2="60" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line2" x1="173" y1="60" x2="237" y2="60" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line3" x1="347" y1="60" x2="283" y2="60" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line4" x1="60" y1="147" x2="60" y2="83" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line5" x1="73" y1="160" x2="137" y2="160" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line6" x1="151" y1="69" x2="76" y2="144" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line7" x1="260" y1="73" x2="260" y2="137" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line8" x1="347" y1="160" x2="283" y2="160" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line id="line9" x1="160" y1="73" x2="160" y2="137" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                            <path id="path1" d="M269 51 Q 305 30 344 45" marker-end="url(#Triangle)" fill="none"
                                  stroke="black" stroke-width="2"/>
                            <path id="path2" d="M365 72 Q 385 100 370 140" marker-end="url(#Triangle)" fill="none"
                                  stroke="black" stroke-width="2"/>
                            <path id="path3" d="M355 148 Q 335 110 350 80" marker-end="url(#Triangle)" fill="none"
                                  stroke="black" stroke-width="2"/>
                            <path id="path4" d="M247 162 Q 220 185 180 170" marker-end="url(#Triangle)" fill="none"
                                  stroke="black" stroke-width="2"/>
                            <path id="path5" d="M172 155 Q 205 130 241 148" marker-end="url(#Triangle)" fill="none"
                                  stroke="black" stroke-width="2"/>

                            <text x="434" y="20">Stack</text>
                            <line x1="430" y1="30" x2="430" y2="245" stroke="black" stroke-width="2"/>
                            <line x1="470" y1="30" x2="470" y2="245" stroke="black" stroke-width="2"/>
                            <line x1="430" y1="245" x2="470" y2="245" stroke="black" stroke-width="2"/>

                        </svg>
                        <div class="kosaraju_demonstration_tip">
                            <p>Hover on graph to start demonstration</p>
                        </div>
                    </div>

                </div>
            </div>

            <div class="line"></div>
            <div class="white_block"></div>

            <div id="tarjan">
                <p>• Tarjan's algorithm</p>
                <div class="tarjan_sub_container">

                    <p> Тhe next algorithm that we are going to discuss is also based on depth-first search as the
                        previous one. A depth-first search begins from any node, and it visits every node of the graph
                        exactly once. Thus, DFS search produces a DFS tree/forest, and Strongly Connected Components
                        form subtrees of the DFS tree. The roots of these subtrees are the "roots" of the SCC. Any node
                        of an SCC might be the root if it is the first node of the component that is discovered by the
                        search. If we can find the root of such subtrees, we can print all the nodes in that subtree and
                        that will be one SCC.</p>
                    <div>
                        <svg width="500" height="180" id="figure_6_svg">
                            <circle cx="40" cy="80" r="12" fill="#1F77B4" stroke="#15537D" stroke-width="2"/>
                            <text x="36" y="84">A</text>
                            <circle cx="120" cy="80" r="12" fill="#FF7F0E" stroke="#B25809" stroke-width="2"/>
                            <text x="116" y="84">B</text>
                            <circle cx="200" cy="80" r="12" fill="#2CA02C" stroke="#217C21" stroke-width="2"/>
                            <text x="196" y="84">C</text>
                            <circle cx="120" cy="150" r="12" fill="#D62728" stroke="#951B1C" stroke-width="2"/>
                            <text x="116" y="154">D</text>
                            <circle cx="280" cy="80" r="12" fill="#9467BD" stroke="#674884" stroke-width="2"/>
                            <text x="276" y="84">E</text>
                            <circle cx="360" cy="80" r="12" fill="#8C564B" stroke="#623C34" stroke-width="2"/>
                            <text x="356" y="84">F</text>
                            <circle cx="280" cy="150" r="12" fill="#E377C2" stroke="#AF5B95" stroke-width="2"/>
                            <text x="276" y="154">G</text>
                            <circle cx="440" cy="20" r="12" fill="#7F7F7F" stroke="#585858" stroke-width="2"/>
                            <text x="436" y="24">J</text>
                            <circle cx="440" cy="80" r="12" fill="#BCBD22" stroke="#8D8E18" stroke-width="2"/>
                            <text x="438" y="84">I</text>
                            <circle cx="440" cy="150" r="12" fill="#17BECF" stroke="#108590" stroke-width="2"/>
                            <text x="436" y="154">H</text>

                            <line x1="53" y1="80" x2="97" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="133" y1="80" x2="177" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="191" y1="89" x2="136" y2="134" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="213" y1="80" x2="257" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="293" y1="80" x2="337" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="351" y1="89" x2="296" y2="134" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="369" y1="89" x2="424" y2="134" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="440" y1="137" x2="440" y2="103" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="440" y1="67" x2="440" y2="43" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="111" y1="141" x2="56" y2="96" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="209" y1="89" x2="264" y2="134" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="280" y1="137" x2="280" y2="103" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                            <path d="M191 71 Q 120 30 56 65" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M449 29 Q 490 70 456 134" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>

                        </svg>

                    </div>


                    <div>
                        <svg width="640" height="220" id="figure_7_svg">
                            <circle cx="40" cy="80" r="12" fill="#1F77B4" stroke="#15537D" stroke-width="2"/>
                            <text x="36" y="84">A</text>
                            <text x="31" y="64">1/1</text>
                            <circle cx="120" cy="80" r="12" fill="#FF7F0E" stroke="#B25809" stroke-width="2"/>
                            <text x="116" y="84">B</text>
                            <text x="112" y="64">2/1</text>
                            <circle cx="200" cy="80" r="12" fill="#2CA02C" stroke="#217C21" stroke-width="2"/>
                            <text x="196" y="84">C</text>
                            <text x="192" y="64">3/1</text>
                            <circle cx="280" cy="20" r="12" fill="#D62728" stroke="#951B1C" stroke-width="2"/>
                            <text x="276" y="24">D</text>
                            <text x="272" y="44">4/1</text>
                            <circle cx="280" cy="140" r="12" fill="#9467BD" stroke="#674884" stroke-width="2"/>
                            <text x="276" y="144">E</text>
                            <text x="272" y="124">5/3</text>
                            <circle cx="360" cy="140" r="12" fill="#8C564B" stroke="#623C34" stroke-width="2"/>
                            <text x="356" y="144">F</text>
                            <text x="352" y="164">6/3</text>
                            <circle cx="440" cy="200" r="12" fill="#E377C2" stroke="#AF5B95" stroke-width="2"/>
                            <text x="436" y="204">G</text>
                            <text x="432" y="184">7/3</text>
                            <circle cx="600" cy="80" r="12" fill="#7F7F7F" stroke="#585858" stroke-width="2"/>
                            <text x="596" y="84">J</text>
                            <text x="592" y="104">10/6</text>
                            <circle cx="520" cy="80" r="12" fill="#BCBD22" stroke="#8D8E18" stroke-width="2"/>
                            <text x="518" y="84">I</text>
                            <text x="514" y="104">9/6</text>
                            <circle cx="440" cy="80" r="12" fill="#17BECF" stroke="#108590" stroke-width="2"/>
                            <text x="436" y="84">H</text>
                            <text x="432" y="104">8/6</text>

                            <line x1="53" y1="80" x2="97" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="133" y1="80" x2="177" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="209" y1="71" x2="260" y2="30" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="209" y1="89" x2="260" y2="130" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="293" y1="140" x2="337" y2="140" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="369" y1="149" x2="420" y2="190" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="369" y1="131" x2="420" y2="90" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="453" y1="80" x2="497" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="533" y1="80" x2="577" y2="80" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                            <path d="M190 90 Q 120 120 60 90" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2" stroke-dasharray="3,3"/>
                            <path d="M267 20 Q 120 20 55 64" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2" stroke-dasharray="3,3"/>
                            <path d="M427 200 Q 330 200 290 160" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2" stroke-dasharray="3,3"/>
                            <path d="M590 70 Q 520 30 456 64" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2" stroke-dasharray="3,3"/>

                        </svg>
                        <br/>Figure 7: Graph and one of it’s DFS tree
                    </div>

                    <p> In above Figure, in DFS tree, continuous arrows are tree edges and dashed arrows are back
                        edges.</p>
                    <p> We run DFS on the graph and compute two values for each node in DFS tree:<br>
                        &emsp;1. "Disc": Its order of first being discovered in DFS.<br>
                        <!--Disc: This is the time when a node is visited 1st time while DFS traversal.<br>-->
                        &emsp;2. "Low": The order of oldest ancestor it can reach.
                    <p>Initially, both properties are same for every node. The 1st property remains constant, and the
                        2nd one may be changed during recursive DFS calls that used to find back edges to ancestors. The
                        “Low” value of a node tells the topmost reachable ancestor that is equal to its "Disc" value
                        anyway. So, for any node, we update this value then we find its ancestor with minimum possible
                        "Disc" value.</p>

                    <p> To find the head of an SCC, we calculate "Disc" and "Low". A node u is head if Disc[u] = Low[u].<br>
                        For any vertex if both properties are the same after recursive DFS calls then it is either:<br>
                        &emsp;1. An isolated vertex that is not part of any cycle.<br>
                        &emsp;2. Part of a cycle and so all of its descendant can reach it. In other words, we can start
                        from this vertex and find all the descendant vertices.</p>
                    <p><b>To summarize, let us define Tarjan's algorithm as follows:</b></p>
                    <p> Tarjan's strongly connected components algorithm performs a single pass of depth-first search.
                        The vertices that have been explored by the search but not yet assigned to a component are kept
                        in a stack. "Low" property of each vertex is computed which is used to determine a set of
                        vertices of a new component.</p>

                    <p>Following is detailed Tarjan’s algorithm:</p>
                    <p>&emsp;• Start from any arbitrary vertex.</p>
                    <p>&emsp;• DFS from that vertex. For each node x, keep two numbers: Disc[x] and Low[x].</p>
                    <p>&emsp;• All nodes with the same Low[x] are in the same strongly connected component.</p>

                </div>
            </div>

            <div class="line"></div>
            <div class="white_block"></div>

            <div id="path">
                <p>• Gabow's path-based algorithm</p>
                <div class="path_sub_container">
                    <p>
                        Our next algorithm is path-based and like the previous ones, its also based on depth-first
                        search. Here, we use two stacks: one of the stacks for keeping track of the vertices not yet
                        assigned to components, and another one for keeping track of the current path in the depth-first
                        search tree.
                    </p>

                    <p><b>Following is detailed Gabow'’s algorithm:</b></p>
                    <p>&emsp;• Let <em>S</em> and <em>B</em> are empty stacks.</p>
                    <p>&emsp;• Set the pre-order number v to <em>C</em>, and increment <em>C</em>.</p>
                    <p>&emsp;• Push <em>v</em> into <em>S</em> and <em>B</em>.</p>
                    <p>&emsp;• Per each edge(<em>v</em>, <em>u</em>).</p>
                    <p>&emsp;&emsp;• If pre-order number of <em>u</em> has not assigned.</p>
                    <p>&emsp;&emsp;&emsp;• Start DFS<em>(u)</em>.</p>
                    <p>&emsp;&emsp;• Else if <em>u</em> has not yet been assigned to a scc.</p>
                    <p>&emsp;&emsp;&emsp;• Repeatedly pop vertices from <em>B</em> until the top element has a pre-order
                        number less than or equal to pre-order number of <em>u</em>.</p>
                    <p>&emsp;• If <em>v</em> is the top element of <em>B</em>.</p>
                    <p>&emsp;&emsp;• Pop vertices from <em>S</em> until <em>v</em> has been popped and assign the popped
                        vertices to a new component.</p>
                    <p>&emsp;&emsp;• Pop <em>v</em> from <em>B</em>.</p>

                    <p><b>Demonstration of Gabow's Algorithm</b></p>
                    <div id="gabow_demonstration_div">
                        <svg width="500" height="300" id="gabow_demonstration">
                            <circle id="gabow_circle1" cx="160" cy="30" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="156" y="34">A</text>
                            <circle id="gabow_circle2" cx="160" cy="90" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="156" y="94">B</text>
                            <circle id="gabow_circle3" cx="160" cy="150" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="156" y="154">C</text>
                            <circle id="gabow_circle4" cx="100" cy="210" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="96" y="214">D</text>
                            <circle id="gabow_circle5" cx="220" cy="210" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="216" y="214">E</text>
                            <circle id="gabow_circle6" cx="220" cy="270" r="12" fill="#1F77B4" stroke="#15537D"
                                    stroke-width="2"/>
                            <text x="216" y="274">F</text>


                            <line x1="160" y1="103" x2="160" y2="127" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="151" y1="159" x2="116" y2="194" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>
                            <line x1="169" y1="159" x2="204" y2="194" stroke="black" stroke-width="2"
                                  marker-end="url(#Triangle)"/>

                            <path d="M151 81 Q 140 65 146 45" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M171 36 Q 185 50 175 75" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M171 144 Q 210 80 178 35" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M208 215 Q 195 235 206 253" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>
                            <path d="M230 262 Q 245 240 236 225" marker-end="url(#Triangle)" fill="none" stroke="black"
                                  stroke-width="2"/>


                            <text x="280" y="150">DFS Stack:</text>
                            <text x="280" y="170">Boundary Stack:</text>
                        </svg>
                        <div class="gabow_demonstration_tip">
                            <p>Hover on graph to start demonstration</p>
                        </div>
                    </div>
                    <p>Gabow's and Tarjan's algorithms are desirable in practice since they require only one depth-first
                        search instead of two. However, Kosaraju's algorithm is simple in implementation.</p>

                </div>
            </div>

            <div class="line"></div>

        </div>

        <div id="complexity1" class="page">
            <div>
                <p>Time Complexity</p>
                <div class="complexity_sub_container">
                    <p>Kosaraju's (Kosaraju-Sharir) Algorithm Complexity analysis</p>
                    <div id="kos_complex">
                        <p>Let us explore the runtime of the Kosaraju's algorithm.<br>
                            As we discussed in the <a id="clink1" class="toOverview"
                                                      href="#algorithms"><em>Algorithm's</em></a> section, the
                            Kosaraju's algorithm performs two depth-first searches on the graph and one graph reversion.
                        </p>
                        <p>The runtime of the Kosaraju's equals to the sum of:<br>
                            &emsp;1) the runtime for running depth-first search starting from each node in the
                            graph.<br>
                            &emsp;2) the runtime for reversing the graph<br>
                            &emsp;3) the runtime for running a depth-first search in the reversed graph.</p>
                        <p>Two complete traversals of the graph takes twice the running time of depth-first search. DFS
                            runs in O(|V| + |E|) time if we use an <a id="clink2" class="toOverview"
                                                                      href="#adjacency_list"><em>adjacency list</em></a>,<a
                                    id="c1" class="ref" href="#body">[22]</a> and O(|V|<sup>2</sup>) time if you use an
                            <a id="clink3" class="toOverview" href="#adjacency_matrix"><em>adjacency matrix</em></a>.
                            Hence, an adjacency list is asymptotically faster if the graph is sparse.<br>
                            For reversing the graph, we traverse all adjacency lists (if we use adjacency lists). If the
                            graph is represented as an adjacency list then the algorithm runs in O(|V| + |E|) time, if
                            the graph is represented as an adjacency matrix then the algorithm runs in O(|V|<sup>2</sup>)
                            time.<br>
                        <p>So, the total runtime of Kosaraju-Sharir algorithm equals to 2 * O(V + E) + O(V + E) = O(V +
                            E).<a id="c2" class="ref" href="#body">[23]</a></p>
                    </div>

                    <p>Tarjan's and Gabow's Algorithms Complexity analysis</p>
                    <div id="tar_complex">
                        <p> As we discussed in the <a id="clink4" class="toOverview"
                                                      href="#algorithms"><em>Algorithm's</em></a> section, the Tarjan's
                            algorithm and the Gabow's algorithm performs only one complete traversal of the graph.<br>
                            If the graph is represented as an adjacency list then the algorithm runs in O(|V|+|E|) time.
                            If the graph is represented as an adjacency matrix then the algorithm runs in
                            O(|V|<sup>2</sup>) time.<br>
                            The first linear time version of Gabow's algorithm was published by Edsger W. Dijkstra in
                            1976.</p>

                        </p>
                    </div>

                    <p>Comparison of Algorithms</p>
                    <div id="comparison">
                        <p>Although, both Kosaraju and Tarjan algorithms have asymptotically linear running time, the
                            Tarjan algorithm is more efficient than Kosaraju, because the algorithm uses DFS traversal
                            only once.
                            In other words, the Tarjan's algorithm runs faster than the Kosaraju-Sharir algorithm,
                            because of the constant factor of running time.<br>
                        </p>
                        <p>Now, let's look at Tarjan and Gabow algorithms, which are more interesting in terms of
                            comparisons of running time.<br>
                            Few results of the experiments done on Tarjan's and Gabow's algorithms, are represented
                            bellow.<a id="c3" class="ref" href="#body">[24]</a></p>
                        <div>
                            <p id="figure8"></p>
                            <img src="content/images/comparison-dense-graph.jpg">
                            <br/>Figure 8: Gabow's vs Tarjan's running time (in seconds) comparison on Dense in dynamic
                            graph representation
                            <p>In <a class="links" href="#figure8"><em>Figure 8</em></a> the running times of both
                                algorithms on Dense graph is represented based on test results. It is explicit, that
                                Gabow's taking less time to compute strongly connected components of directed Dense
                                graph.</p>
                        </div>


                        <div>
                            <p id="figure9"></p>
                            <img src="content/images/comparison-sparse-graph.jpg">
                            <br/>Figure 9: Gabow's vs Tarjan's running time (in seconds) comparison on Sparse in dynamic
                            graph representation
                            <p>However, when the number of edges is small, Gabow's and Tarjan's have the almost the same
                                efficiency rate. The results of this case is depicted in <a class="links"
                                                                                            href="#figure9"><em>Figure
                                    9</em></a>.</p>
                        </div>

                        <div>
                            <p id="figure10"></p>
                            <img src="content/images/comparison-complete-graph.jpg">
                            <br/>Figure 10: Gabow's vs Tarjan's running time (in seconds) comparison on Complete in
                            dynamic graph representation
                            <p><a class="links" href="#figure10"><em>Figure 10</em></a> shows the test results for
                                Complete graph. It turns out that Gabow's algorithm is doing better than Tarjan's
                                algorithm as the number of nodes and edges goes up</p>
                        </div>

                        <p> The Gabow's algorithm seems to be faster when it runs on Dense or Complete graphs, and
                            Tarjan's performance is similar to Gabow's algorithm when number of edges in a graph is
                            minimum. So, we can conclude that in our collection of algorithms, Gabow's algorithm, in
                            fact, is much more easier, shorter and runs much more faster.</p>
                    </div>

                </div>
            </div>
            <div class="line"></div>
        </div>


        <div id="applications1" class="page">
            <div>
                <p>Applications</p>
                <div class="applications_sub_container">
                    <p>The distinguishable property of many graph algorithm problems is their complexity. As graphs get
                        larger, the computations on them can become very time consuming and complicated․ So our goal is
                        to find ways for decreasing that complexity when it is possible and make algorithms faster.<br>
                        One optimal approach for this goal is parallelism: when the problem is divided into smaller
                        pieces that can be executed and solved at the same time.</p>
                    <p> In the case of graphs, there exists a very intuitive way of dividing the problem into smaller
                        subproblems. We can divide the given graph into the set of subgraphs.<br>
                        So by identifying the strongly connected components of the graph we are automatically
                        decomposing them and we can implement a divide-and-conquer method and perform the algorithm on
                        those components, and then merge the results.<br>
                        First we find the strongly connected components and merge them into a single vertex. We end up
                        with a new graph, on which we can compute any property we want. At the end, we merge the results
                        by using the contracted graph.
                        If the graph is complex enough, we can again divide it into its own strongly connected
                        subgraphs. </p>
                    <p> Let us give an example.
                        Graph coloring is an NP-complete problem, it means that the optimal solution for graph coloring
                        algorithm on an arbitrary graph grows exponentially as the size of the graph increases.<br>
                        We can apply our method as follows: find the strongly connected components and color them
                        simultaneously. Then we can merge the coloring results by joining the strongly connected
                        components.</p>
                    <p>Although this approach helps us to reduce running time of a graph coloring, in some cases the
                        merging operation can be expensive enough to prevail the savings of the subgroup decomposition
                        tactic. But, in general, this appears to be a useful way of finding the optimal coloring
                        solution.</p>
                    <p>The other use of strongly connected component computing algorithms may be in social networks.<br>
                        Let us consider a group of people that are connected to each other by the university they attend
                        or any other common thing they have. We can define this group as strongly connected. Many people
                        in this group will probably have common interests, for example, pages or games in Facebook. The
                        strongly connected component algorithms can be used for finding and analysing such groups,
                        suggesting them commonly liked pages and games, or just for improving advertisement showing
                        process based on the communities that users belong to.<br>
                        Also, the strongly connected component algorithms can be applied for finding instances in a huge
                        data hub that may be connected to each other and make suggestions. A good example may be
                        Facebook friend recommendations or LinkedIn connections (first, second, third). </p>
                    <p>The other use of strongly connected component algorithms is cluster identification. We may think
                        of an each item as a vertex and add an edge between them if they are considered "similar". The
                        strongly connected components of this graph will represent different types of items.</p>

                    <p>In addition, strongly connected component algorithms may be used to:<br>
                        &emsp;1) compute the Dulmage–Mendelsohn decomposition<a id="a1" class="ref"
                                                                                href="#body">[25]</a><br>
                        &emsp;2) solve 2-satisfability problems<a id="a2" class="ref" href="#body">[26]</a><br>
                        &emsp;3) solve some transportation related problems<br>
                        &emsp;4) improve running time of algorithms that can be implemented using decomposition-merging
                        method</p>
                    <p>As we saw, strongly connected component algorithms can be used as a supporting step in many graph
                        algorithms that are based on decomposition. After decomposition, the algorithm is run separately
                        on each strongly connected component.<a id="a3" class="ref" href="#body">[27]</a><br>
                        If we find a way to distribute the computation among a hundred processors and get the results in
                        a few minutes, then our goal is accomplished. But there is a limitation in this approach: we are
                        not able to stop the growth of the execution time by adding a finite number of processors. But
                        in some cases parallelism can be a fast and a handy solution and help us to solve a particular
                        problem, in contrast with not being able to solve it efficiently at all.</p>

                </div>
            </div>
            <div class="line"></div>
        </div>


        <div id="try_it_out1" class="page">
            <div id="divOutputMover">
                <p id="outputMover"></p>
            </div>
            <div>
                <p>Try It Out</p>
                <div class="try_it_out_sub_container">
                    <div class="fr"></div>

                    <div class="gist-readme">
                        <p>Click in the open space to <strong>add a node</strong>, drag from one node to another to
                            <strong>add an edge</strong>. <br>
                            Ctrl-drag a node to <strong>move</strong> the graph layout. <br>
                            Click a node or an edge to <strong>select</strong> it.</p>

                        <p>When a node is selected: <strong>Delete</strong> removes the node. <br>
                            When an edge is selected: <strong>L</strong>(eft), <strong>R</strong>(ight),
                            <strong>B</strong>(oth) change direction, <strong>Delete</strong> removes the edge.
                        </p>

                        <p>Press <strong>ESC</strong> to disable the movement of the moving box.<br>
                            Press one more <strong>ESC</strong> to hide the moving box.
                        </p>
                    </div>

                    <div id="buttonAndFixedText">
                        <div id="divButton">
                            <input id="kosaraju_button" type="button" name="SCC" title="SCC" value="SCC" onclick=""/>
                        </div>
                        <div id="divOutputFixed">
                            <p id="outputFixed"></p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="line"></div>
        </div>


        <div id="resources1" class="page">
            <div>
                <p>Bibliography</p>
                <div class="resources_sub_container">
                    <p>[1] Micha Sharir,<a
                            href="http://ac.els-cdn.com/0898122181900080/1-s2.0-0898122181900080-main.pdf?_tid=f4678382-fe31-11e4-bc73-00000aab0f27&acdnat=1432045303_b111de0826327620e2658244d8a8a081"
                            target="_blank"> A strong-connectivity algorithm and its applications in data flow
                        analysis</a>, <em>Computers and Mathematics with Applications</em> 7 (1) (1981) p. 67-72</p>
                    <p>[2] Robert Tarjan,<a href="http://langevin.univ-tln.fr/cours/PAA/extra/Tarjan-1972.pdf"
                                            target="_blank"> Depth first search and linear graph algorithms</a>, <em>SIAM
                        Journal on Computing</em> 1 (2) (1972) p. 146-160</p>
                    <p>[3] H.N. Gabow,<a
                            href="http://www.cs.princeton.edu/courses/archive/spr09/cos423/Lectures/bi-gabow.pdf"
                            target="_blank"> Path-based depth-first search for strong and biconnected components</a>,
                        Tech. Report CU-CS-890-99, revised version, Dept. of Computer Science, University of Colorado at
                        Boulder, (2000)</a></p>
                    <p>[4] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 591</p>
                    <p>[5] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 675</p>
                    <p>[6] Graph (mathematics), <a href="http://en.wikipedia.org/wiki/Graph_(mathematics)"
                                                   target="_blank">http://en.wikipedia.org/wiki/Graph_(mathematics)</a>
                    </p>
                    <p>[7] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 675</p>
                    <p>[8] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 522</p>
                    <p>[9] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 523</p>
                    <p>[10] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 524</p>
                    <p>[11] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 555-556</p>
                    <p>[12] T.H. Cormen, C.E. Leiserson, R.L. Rivest, <a
                            href="http://syedwaqarahmad.webs.com/documents/t._cormen_-_introduction_to_algorithms_3rd_edition.pdf"
                            target="_blank">Introduction to Algorithms</a>, 3th Edition, (2009) p. 614</a></p>
                    <p>[13], [14] Robin J. Wilson, <a
                            href="http://www.techtud.com/sites/default/files/public/share/GRAPH%20THEORY-%20RJ%20WILSON.pdf"
                            target="_blank">Introduction to Graph Theory</a>, 5th Edition, (2010) p. 139</p>
                    <p>[15] Jon Kleinberg, E´va Tardos, <a href="http://cs.furman.edu/~chealy/cs361/kleinbergbook.pdf"
                                                           target="_blank">Introduction to Algorithms</a>, (2003) p. 36
                    </p>
                    <p>[16] Jon Kleinberg, E´va Tardos, <a href="http://cs.furman.edu/~chealy/cs361/kleinbergbook.pdf"
                                                           target="_blank">Introduction to Algorithms</a>, (2003) p. 35
                    </p>
                    <p>[17] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 624</p>
                    <p>[18] Jørgen Bang-Jensen, Gregory Gutin, <a href="http://www.cs.rhul.ac.uk/books/dbook/main.pdf"
                                                                  target="_blank">Digraphs Theory, Algorithms an
                        Applications</a>, (2007) p. 172</p><!--dfs -> Rosen page 746,764, Cormen 540(22.3)</p>-->
                    <p>[19] Kenneth H. Rosen, <a href="content/resources/Rosen.pdf" target="_blank">Discrete Mathematics
                        and its Applications</a>, 6th Edition, (2006) p. 626</p>
                    <p>[20] T.H. Cormen, C.E. Leiserson, R.L. Rivest, <a
                            href="http://syedwaqarahmad.webs.com/documents/t._cormen_-_introduction_to_algorithms_3rd_edition.pdf"
                            target="_blank">Introduction to Algorithms</a>, 3th Edition, (2009) p. 617</p>
                    <p>[21] T.H. Cormen, C.E. Leiserson, R.L. Rivest, <a
                            href="http://syedwaqarahmad.webs.com/documents/t._cormen_-_introduction_to_algorithms_3rd_edition.pdf"
                            target="_blank">Introduction to Algorithms</a>, 3th Edition, (2009) p. 616</p>
                    <p>[22] Jon Kleinberg, E´va Tardos, <a href="http://cs.furman.edu/~chealy/cs361/kleinbergbook.pdf"
                                                           target="_blank">Introduction to Algorithms</a>, (2003) p. 43
                    </p>
                    <p>[23] T.H. Cormen, C.E. Leiserson, R.L. Rivest, <a
                            href="http://syedwaqarahmad.webs.com/documents/t._cormen_-_introduction_to_algorithms_3rd_edition.pdf"
                            target="_blank">Introduction to Algorithms</a>, 3th Edition, (2009) p. 606</p>
                    <p>[24] Saleh Alshomrani, Gulraiz Iqbal, <a
                            href="http://www.ijcsi.org/papers/IJCSI-9-4-1-94-100.pdf" target="_blank">Analysis of
                        Strongly Connected Components (SCC) Using Dynamic Graph Representation </a>, IJCSI International
                        Journal of Computer Science Issues, Vol. 9, Issue 4, (2012) </p>

                    <p>[25] Dulmage–Mendelsohn decomposition, <a
                            href="http://en.wikipedia.org/wiki/Dulmage%E2%80%93Mendelsohn_decomposition"
                            target="_blank">http://en.wikipedia.org/wiki/Dulmage Mendelsohn decomposition</a></p>
                    <p>[26] <a href="http://www.math.ucsd.edu/~sbuss/CourseWeb/Math268_2007WS/2SAT.pdf" target="_blank">A
                        Linear-Time Algorithm For Testing The Truth Of Certain Quantified Boolean Formulas*</a>, 8
                        (1978)</p>
                    <p>[27] T.H. Cormen, C.E. Leiserson, R.L. Rivest, <a
                            href="http://syedwaqarahmad.webs.com/documents/t._cormen_-_introduction_to_algorithms_3rd_edition.pdf"
                            target="_blank">Introduction to Algorithms</a>, 3th Edition, (2009) p. 615</p>

                    <!-- <p>articulation point : Rosen page 645, Cormen 558(22-2)</p>
                    <p>[~] A.V ? O. Aho, J.E. Hopcroft, J.D. Ullman, The Design and Analysis
                         of Computer Algorithms, Addison-Wesley, Reading, Massachusetts,
                         1974.</p>
                     <p>[~] A.V. Aho, J.E. Hopcroft, J.D. Ullman, Data Structures and
                         Algorithms, Addison-Wesley, Reading, MA, 1983.</p>
                     <p>[~]<a href="http://www21.in.tum.de/~lammich/pub/gabow_scc.pdf" target="_blank">Peter Lammich. Verified Efficient Implementation of Gabow’s Strongly Connected Component Algorithm. In <em>ITP'14, volume 8558 of LNCS, pages325-340, 2014.</em></a></p>-->


                    <!--http://www.ijcsi.org/papers/IJCSI-9-4-1-94-100.pdf -->
                </div>
            </div>
            <div class="line"></div>
        </div>

    </div>
</div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="content/script/gabow_demonstration_app.js"></script>
<script src="content/script/kosaraju_demonstration_app.js"></script>
<script src="content/script/app.js"></script>
</body>
</html>
